var gtk4demo;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 303:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
// This is the UI of the app defined using super a light-weight JS object.
// Why not Gnome XML? Because Gnome XML super verbose and eventually becomes unreadable
// once the widget tree gets bigger. Most XML properties are useless to me.
// But a declarative UI is still cool and since JSON requires nasty quoting,
// a JS Object seemed the most natural. Also here I can freely express what my
// UI should "be" like and not how it should "look" like.
// I call this a NOGUI specification. It is all about actions, switches, views,
// dialogs, etc.

// UI defines the UI of the app.
var spec = {
    // all icons used by the app
    icons: {
        oscillator: { file: ["icons", "3d-meter-symbolic.svg"] },
        card:  { name: "audio-card" },
        video: { name: "video-x-generic" },
        power: { name: "battery-full-charged" },
        chart: { name: "utilities-system-monitor" },
    },
    // define the main view
    main: "menu",
    // all dialogs used by the app
    dialogs: {
        about: { title: "About Intel GPU Indicator", file: ["about.md"], ok: true, fmt: "md" },
        root:  { title: "Setting up `root` access",  file: ["root.md"],  ok: true, fmt: "md" },
        // TODO: allow setting plan Markdown dialogs using
        // name: "filename.md"
        // and detect everything else automatically
    },
    views: {
        // the main menu with all shortcuts for the indicator
        menu: [
            { title: "Intel GPU Indicator", icon: "card" },        
            { switch: "Video Acceleration", bind:   "showVideo",  icon: "video" },
            { switch: "3D Rendering",       bind:   "showRender", icon: "card" },
            { switch: "Power Usage",        bind:   "showPower",  icon: "power" },
            { action: "Stop Process",       call:   "stopGPUTop" },
            { action: "Setup `root`access", dialog: "root" },
            { action: "Settings",           view:   "settings" },
            { action: "About",              dialog: "about" },
        ],
        // the more elaborate settings dialog
        settings: [
            { title: "Intel GPU Indicator Settings", icon: "card" },
            { switch: "Show Video Acceleration Load",  bind: "showVideo" },
            { switch: "Show 3D Rendering Load",        bind: "showRender" },
            { switch: "Show Power Consumption",        bind: "showPower" },
            { switch: "Run `intel_gpu_top` as `root`", bind: "useRoot" },
            { action: "How to setup `root` access",    dialog: "root" },
            { action: "<-- Back",                      view:   "menu" },
        ],
    }
}

if (!this.module) module = {}
module.exports = { spec }


/***/ }),

/***/ 464:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {


imports.gi.versions.Gtk = '4.0'
const { GLib, Gtk, Gdk, Gio } = __webpack_require__(311)
const ByteArray = __webpack_require__(304)
const system = __webpack_require__(768)

let args  = [system.programInvocationName].concat(ARGV)
let flags = Gio.ApplicationFlags.HANDLES_COMMAND_LINE

const path = (...o) => GLib.build_filenamev(o)
const readFile = (path) => ByteArray.toString(GLib.file_get_contents(path)[1])
const css = (...css_strings) => {
    let cp = new Gtk.CssProvider()
    cp.load_from_data(css_strings.join('\n'))
    return cp
}
const addStyles = (w, ...styles) => {
    const ctx = w.get_style_context()
    styles.forEach((s) => {
        if(typeof s == 'string') s = css(s)
        ctx.add_provider(s, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)
    })
}

const file   = GLib.path_get_basename(args[0])
const dir    = GLib.path_get_dirname(args[0])
const root   = GLib.path_get_dirname(dir)
const src    = path(root, 'src')
const demos  = path(root, 'demos')
const assets = path(root, 'demos', 'assets')

/*
print(`adding ${src} to searchPath`)
imports.searchPath.unshift(src)
print(`adding ${demos} to searchPath`)
imports.searchPath.unshift(demos)
*/

const md2pango = __webpack_require__(760)
const nogui    = __webpack_require__(45)
const repl     = __webpack_require__(883)
const demo     = __webpack_require__(303)

Gtk.init()

// CSS from source code
let styles = {
    dark:       'color: #eee; background-color: #222; padding: 2px;',
    dark_panel: 'background-color: #333; padding: 10px;',
    mp20:       'padding: 20px; margin: 20px;',
    mp10:       'padding: 10px; margin: 10px;',
    mp5:        'padding:  5px; margin:  5px;',
    border1:    'border-width: 1px;',
    border2:    'border-width: 3px;',
    border3:    'border-width: 3px;',
}

let V = {'orientation': Gtk.Orientation.VERTICAL}
let H = {'orientation': Gtk.Orientation.HORIZONTAL}

let add = (parent, widget) => { parent.append(widget); return widget }

function startDemo(app) {
    // setup basic layout
    let w = new Gtk.ApplicationWindow({
        application: app,
    })
    w.set_default_size(400,600)    
    // window class names: windowcontrols, window, windowhandle
    // addStyles(w, `window {${styles.mp20}}`)
    w.show()

    // root container
    let box = new Gtk.Box(V)
    w.set_child(box)

    // menu bar
    let menu = add(box, new Gtk.Box(H))
    let b    = add(menu, new Gtk.Button({'label': 'load ui'}))

    // main content area
    let nav   = add(box, new Gtk.StackSwitcher({stack: new Gtk.Stack()}))
    let stack = add(box, nav.get_stack())
    addStyles(stack, `stack {${styles.mp10}}`)

    // status bar
    let status = add(box, new Gtk.Box(H))

    ctrl = new nogui.Controller({
        window: w,
        data: {
            // bindable properties
            showVideo:  false,
            showRender: false,
            showPower:  false,
            useRoot:    false,
        },
        callbacks: {
            stopGPUTop: () => print("STOP"),
        },
        viewHandler: (n) => stack.set_visible_child_name(n),        
    })

    let formatters = {
        md: { format: (s) => md2pango.convert(s) }
    }

    let ui = null
    let loadUI = () => {
        ui = nogui.buildWidgets(demo.spec, ctrl, assets, formatters)
        for (const i of ui.icons) status.append(i)
        for (const v of ui.views) stack.add_named(v.widget, v.name)
        ctrl.showView(demo.spec.main)
    }

    // main content
    b.connect('clicked', loadUI)

    loadUI()

    // store main vars globally
    // TODO: allow only during debugging remove
    window.ctrl = ctrl
    window.data = ctrl.data
    window.app  = app
    window.ui   = ui
}

function runApp() {
    let app = new Gtk.Application({flags})
    app.connect('startup', () => startDemo(app) )
    app.connect('command-line', (app, cmd) => repl.startRepl(cmd.get_stdin()))
    app.run(null)    
}

if (file.match(/(gtk4-app|demo).(webpack|min)?.js/)) runApp()

/***/ }),

/***/ 760:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
// #!/usr/bin/env node

// SPDX-FileCopyrightText: 2021 Uwe Jugel
//
// SPDX-License-Identifier: MIT

// This file is part of md2pango (https://github.com/ubunatic/md2pango).

const H1="H1", H2="H2", H3="H3", UL="BULLET", OL="LIST", CODE="CODE"
const BOLD="BOLD", EMPH="EMPH", PRE="PRE", LINK="LINK"

let sub_h1, sub_h2, sub_h3

// m2p_sections defines how to detect special markdown sections.
// These expressions scan the full line to detect headings, lists, and code.
const m2p_sections = [
    sub_h1 = { name: H1, re: /^(#\s+)(.*)(\s*)$/,   sub: "<big><big><big>$2</big></big></big>" },
    sub_h2 = { name: H2, re: /^(##\s+)(.*)(\s*)$/,  sub: "<big><big>$2</big></big>" },
    sub_h3 = { name: H3, re: /^(###\s+)(.*)(\s*)$/, sub: "<big>$2</big>" },
    { name: UL, re: /^(\s*[\*\-]\s)(.*)(\s*)$/,   sub: " â€¢ $2" },
    { name: OL, re: /^(\s*[0-9]+\.\s)(.*)(\s*)$/, sub: " $1$2" },
    { name: CODE, re: /^```[a-z_]*$/,             sub: "<tt>" },
]

// m2p_styles defines how to replace inline styled text
const m2p_styles = [
    { name: BOLD, re: /(^|[^\*])(\*\*)(.*)(\*\*)/g, sub: "$1<b>$3</b>" },
    { name: BOLD, re: /(\*\*)(.*)(\*\*)([^\*]|$)/g, sub: "<b>$3</b>$4" },
    { name: EMPH, re: /(^|[^\*])(\*)(.*)(\*)/g,   sub: "$1<i>$3</i>" },
    { name: EMPH, re: /(\*)(.*)(\*)([^\*]|$)/g,   sub: "<i>$3</i>$4" },    
    { name: PRE,  re: /(`)([^`]*)(`)/g,           sub: "<tt>$2</tt>" },
    { name: LINK, re: /(!)?(\[)(.*)(\]\()(.+)(\))/g,  sub: "<a href='$5'>$3</a>" },
    { name: LINK, re: /(!)?(\[)(.*)(\]\(\))/g,        sub: "<a href='$3'>$3</a>" },
]

const re_comment = /^\s*<!--.*-->\s*$/
const re_color = /^(\s*<!--\s*(fg|bg)=(#?[0-9a-z_A-Z-]*)\s*((fg|bg)=(#?[0-9a-z_A-Z-]*))?\s*-->\s*)$/
const re_reset = /(<!--\/-->)/
const re_uri = /http[s]?:\/\/[^\s']*/
const re_href = "/href='(http[s]?:\\/\\/[^\\s]*)'"
const re_atag = "<a\s.*>.*(http[s]?:\\/\\/[^\\s]*).*</a>/"
const re_h1line = /^===+\s*$/
const re_h2line = /^---+\s*$/

const m2p_escapes = [
    [/<!--.*-->/, ''],
    [/&/g, '&amp;'],
    [/</g, '&lt;'],
    [/>/g, '&gt;'],    
]

const code_color_span = "<span foreground='#bbb' background='#222'>"

const escape_line  = (line) => m2p_escapes.reduce((l, esc) => l.replace(...esc), line)

const pad = (lines, start=1, end=1) => {
    let len = lines.reduce((n, l) => l.length > n ? l.length : n, 0)
    return lines.map((l) => l.padEnd(len + end, ' ').padStart(len + end + start, ' '))
}

function convert(text) {
    let lines = text.split('\n')
    let code = false
    let out = []
    let pre = []
    let color_span_open = false
    let tt_must_close = false

    const try_close_span = () => {
        if (color_span_open) {
            out.push('</span>')
            color_span_open = false
        }
    }
    const try_open_span = () => {
        if (!color_span_open) {
            out.push('</span>')
            color_span_open = false
        }
    }


    for (const line of lines) {
        // first parse color macros in non-code texts
        if(!code) {
            let colors = line.match(re_color)
            if (colors || line.match(re_reset)) try_close_span()
            if (colors) {
                try_close_span()
                if(color_span_open) close_span()
                let fg = colors[2] == 'fg'? colors[3] : colors[5] == 'fg'? colors[6] : ''
                let bg = colors[2] == 'bg'? colors[3] : colors[5] == 'bg'? colors[6] : ''
                let attrs = ''
                if(fg != '') { attrs += ` foreground='${fg}'`}
                if(bg != '') { attrs += ` background='${bg}'`}
                if (attrs != '') {                
                    out.push(`<span${attrs}>`)
                    color_span_open = true
                }
            }
        }
        // all macros processed, lets remove remaining comments
        if (line.match(re_comment)) continue

        // escape all non-verbatim text
        let result = code? line : escape_line(line)
        let code_start = false
        let match = null
        for (sec of m2p_sections) {
            if (match = line.match(sec.re)) {
                switch (sec.name) {
                    case CODE:
                        if (!code) {
                            code_start=true
                            if (color_span_open) {
                                // cannot color
                                result = '<tt>'
                                tt_must_close = false
                            } else {
                                result = code_color_span + '<tt>'
                                tt_must_close = true
                            }
                        }
                        else {
                            out.push(...pad(pre).map(escape_line))
                            result='</tt>'
                            if (tt_must_close) {
                                result += '</span>'
                                tt_must_close = false
                            }
                        }
                        code=!code
                        break
                    default:
                        if (code) result = line
                        else      result = line.replace(sec.re, sec.sub)
                        break
                }
                break
            }
        }
        if (code && !code_start) {
            pre.push(result)
            continue
        }
        if (line.match(re_h1line)) {
            out.push(`# ${out.pop()}`.replace(sub_h1.re, sub_h1.sub))
            continue
        }
        if (line.match(re_h2line)) {
            out.push(`## ${out.pop()}`.replace(sub_h2.re, sub_h2.sub))
            continue
        }
        // all other text can be styled
        for (const style of m2p_styles) {
            result = result.replace(style.re, style.sub)
        }
        // all raw urls can be linked if possible
        let uri  = result.match(re_uri)    // look for any URI
        let href = result.match(re_href)   // and for URIs in href=''
        let atag = result.match(re_atag)   // and for URIs in <a></a>
        href = href && href[1] == uri
        atag = href && atag[1] == uri
        if (uri && (href || atag)) {
            result = result.replace(uri, `<a href='${uri}'>${uri}</a>`)
        }
        out.push(result)
    }

    try_close_span()
    return out.join('\n')
}

const readFile = (f) => {
    // node.js only and when running from the command line
    const fs = __webpack_require__(59)
    return fs.readFileSync(f, 'utf8')
}

let __is_nodejs_main = false
try {
    // node.js specific checks and exports
    __is_nodejs_main = (__webpack_require__.c[__webpack_require__.s] === module)
    exports.convert = convert
} catch(e) {}

if (__is_nodejs_main) {
    // running in node.js called from the CLI
    let args = process.argv.slice(2)
    if (args.length == 0 || args.find((a) => a == '-h')) {
        console.log(`Usage: ${process.argv[1]} FILE [FILE...]`)
        process.exit(0)
    }
    args.forEach((f) => process.stdout.write(convert(readFile(f))))
}


/***/ }),

/***/ 45:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
// nogui transforms a non-graphical UI spec to a widget tree
// see `assets/ui.js` to learn what features are supported.

const { Gtk, Gdk, Gio, GLib, Clutter } = imports.gi
const ByteArray = imports.byteArray

const keys  = Object.keys
const items = (o) => keys(o).map((k) => [k, o[k]])
const toPath = (...args) => GLib.build_filenamev(args)
const readFile = (path) => ByteArray.toString(GLib.file_get_contents(path)[1])

// RESPONSE_TYPE defines nogui-dialog response types.
// The response types are more generic than `Gtk.ResponseType` codes
// and are passed additional argument to `Gtk.Dialog` callbacks.
// Also see https://gjs-docs.gnome.org/gtk40~4.0.3/gtk.responsetype
// and `gtkToNoguiResponseCode`.
const RESPONSE_TYPE = {
    HELP:   'HELP',  // HELP 
    OK:     'OK',
    NOT_OK: 'NOT_OK',
    OTHER:  'OTHER',
}

let V = {'orientation': Gtk.Orientation.VERTICAL}
let H = {'orientation': Gtk.Orientation.HORIZONTAL}

let add = (parent, widget) => { parent.append(widget); return widget }

const gtkToNoguiResponseCode = (response_code) => {
    // see: https://gjs-docs.gnome.org/gtk40~4.0.3/gtk.responsetype
    switch(response_code) {
        case Gtk.ResponseType.APPLY:
        case Gtk.ResponseType.YES:
        case Gtk.ResponseType.OK:     return RESPONSE_TYPE.OK
        case Gtk.ResponseType.CANCEL: 
        case Gtk.ResponseType.NO:     
        case Gtk.ResponseType.CLOSE:  return RESPONSE_TYPE.NOT_OK
        case Gtk.ResponseType.HELP:   return RESPONSE_TYPE.HELP
        default:                      return RESPONSE_TYPE.OTHER
    }    
}

const addStyles = (w, ...styles) => {
    const ctx = w.get_style_context()
    styles.forEach((obj) => {
        if(typeof obj == 'string') {
            const cp = new Gtk.CssProvider()
            cp.load_from_data(obj)
            obj = cp
        }
        ctx.add_provider(obj, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)
    })
}

var Controller = class Controller {
    constructor({window={}, data={}, callbacks={}, dialogs={}, viewHandler=null}) {
        this.window      = window       
        this.data        = data
        this.callbacks   = callbacks
        this.dialogs     = dialogs
        this.viewHandler = viewHandler
        this.bindings    = bindAll(data)
    }
    showView(name) {
        if (!this.viewHandler) throw new Error(`Controller.viewHandler not set`)
        this.viewHandler(name)
    }
    callBack(name) {
        if(name in this.callbacks) return this.callbacks[name]()
        logError(new Error(`callback '${name}' not found`))
    }
    openDialog(name)  {        
        if(name in this.dialogs) {
            return this.dialogs[name].run(this.window)
        }
        logError(new Error(`dialog '${name}' not found`))    
    }
    /**
    * @callback valueSetter
    * @param {*} value - the changed value
    */
    /**
     * @param {string} name 
     * @param {valueSetter} onChange
     * @returns {{id: number, setter: valueSetter}}
     */
    bindProperty(name, onChange) {
        let b = this.bindings[name]
        if (!b) {
            throw new Error(`missing binding ${name}`)
        }
        const id = b.connect(onChange)
        return {id, setter:b.setter}
    }
    unbindProperty(name, id) {
        let b = this.bindings[name]
        if (b) b.disconnect(id)
    }    
    _add_dialogs(dialogs) {
        dialogs.forEach(d => this.dialogs[d.name] = d)
    }    
}

var Binding = class Binding {
    constructor(obj, field) {
        this.targets = {}
        this.bind_id = 0
        this.field   = field
        this.obj     = obj
        this.value   = obj[field]  // read default value
        this.getter = () => obj[field]
        this.setter = (val) => {            
            if (val != this.value) {
                this.value = val
                this.notify()
            }
        }
        
        Object.defineProperty(obj, field, {
            get: this.getter,
            set: this.setter,
        })
    
        obj[field] = this.value
    }
    notify(){
        Object.values(this.targets).forEach(t => t(this.value))
        return this
    }
    connect(onChange){
        const id = (this.bind_id++)
        this.targets[id] = onChange
        return id
    }
    disconnect(id){
        delete this.targets[id]
    }
}

/**
 * bindAll creates a nogui.Binding for all properties of `data`.
 * 
 * @param {object} data 
 * @returns {Object.<string, Binding>}
 */
function bindAll(data) {
    let bindings = {}
    for (const k in data) {
        if (typeof data[k] != 'function') bindings[k] = new Binding(data, k)
    }    
    return bindings
}

var poly = {
    isGtk3: () => Gtk.MAJOR_VERSION < 4,
    append: (container, o) => {
        if (container.append) return container.append(o)
        // No append available, must try other ways!
        if (container instanceof Gtk.Box) {
            return box.pack_start(o, true, false, '1.0')
        }
        throw new Error(`append(widget) not implemented for ${container}`)
    },
    runDialog: (dia, cb=null, close=true) => {
        dia.show()
        dia.connect('response', (o, id) => {            
            if (cb) cb(id, gtkToNoguiResponseCode(id))
            if (id != Gtk.ResponseType.CLOSE && close) dia.close()
        })
    },
    getDisplay: () => Gdk.Display.get_default(),
    getScreen:  () => poly.getDisplay().get_default_screen(),
    getTheme:   () => {
        const T = Gtk.IconTheme
        if (T.get_for_display) return T.get_for_display(poly.getDisplay())
        if (T.get_for_screen)  return T.get_for_screen(poly.getScreen())
        return Gtk.IconTheme.get_default()
    },
    addIconPath: (path) => {
        const theme = poly.getTheme()
        if (theme.add_search_path)    theme.add_search_path(path)
        if (theme.append_search_path) theme.append_search_path(path)
    }
}

function buildIcons(icons, path) {
    // allow finding icons by name
    poly.addIconPath(path)

    return items(icons).map(([k,spec]) => {        
        const str = JSON.stringify(spec)
        let img        
        if (spec.name) {
            img = new Gtk.Image({ icon_name: spec.name, use_fallback: true })
        }
        else if (spec.file) {
            let icon_path = toPath(path, ...spec.file)
            log(`load icon: ${str} from ${icon_path}`)
            const gicon = Gio.FileIcon.new(Gio.File.new_for_path(icon_path))
            img = new Gtk.Image({gicon: gicon, use_fallback: true})
        }
        if (img == null) {            
            img = Gtk.Image({ icon_name: "image-missing", use_fallback: true })
            logError(new Error(`failed to load icon ${k}: ${str}`), 'using placeholder')
        } else {
            log(`loaded icon ${k}: ${str}`)
        }
        return img
    })
}

function loadDialogFile(file, path, formatter=null) {
    if (typeof file == 'string') file = [file]
    let text = readFile(toPath(path, ...file))
    if (formatter != null) text = formatter.format(text)
    return text
}

function buildDialogs(dialogs, path, formatters) {
    // const flags = Gtk.DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL;
    return items(dialogs).map(([k,spec]) => {
        const str = JSON.stringify(spec)
        let fmt = (spec.fmt && formatters && formatters[spec.fmt]) || null
        const createDialog = (window) => {
            const w = new Gtk.Window()          
            const dialog = new Gtk.MessageDialog({
                // flags: Gtk.DialogFlags.DESTROY_WITH_PARENT,
                title: spec.title,
                text: loadDialogFile(spec.file, path, fmt),
                buttons: [Gtk.ButtonsType.OK],
                use_markup: true,
                modal: false,
                transient_for: window,
                message_type: Gtk.MessageType.OTHER,
            })
            // make dialog movable by adding a title bar
            const hdr = new Gtk.HeaderBar({ decoration_layout: 'icon:close' })
            dialog.set_titlebar(hdr)
            log(`loaded dialog ${k}: ${str}`)
            return dialog
        }
        let run = (window) => poly.runDialog(createDialog(window))
        log(`setup dialog ${k}: ${str}`)
        return { spec, name:k, run:run }
    })
}

/**
 * 
 * @param {Object} views 
 * @param {Controller} ctrl 
 * @returns {{name:string, widget:Gtk.Box}[]}
 */
function buildViews(views, ctrl) {

    return items(views).map(([k, spec]) => {
        // TODO: add icons from "icon" property

        let box = new Gtk.Box(V)
        for (const row of spec) {
            if      (row.title)  {
                let l = add(box, new Gtk.Label({label:row.title}))
                addStyles(l, 'label {padding: 5px;}')
            }
            else if (row.action) {
                let b = add(box, new Gtk.Button({label:row.action}))                
                if (row.call)   b.connect('clicked', () => ctrl.callBack(row.call))
                if (row.dialog) b.connect('clicked', () => ctrl.openDialog(row.dialog))
                if (row.view)   b.connect('clicked', () => ctrl.showView(row.view))
                addStyles(b, 'button {margin: 5px;}')
            }
            else if (row.switch) {
                let lane = add(box, new Gtk.Box(H))
                let l    = add(lane, new Gtk.Label({label:row.switch}))
                let sw   = add(lane, new Gtk.Switch())
                if (row.call)   sw.connect('state-set', () => ctrl.callBack(row.call))
                if (row.dialog) sw.connect('state-set', () => ctrl.openDialog(row.dialog))
                if (row.view)   sw.connect('state-set', () => ctrl.showView(row.view))
                if (row.bind) {
                    let onChange = (value) => value? sw.set_state(true) : sw.set_state(false)
                    let {id, setter} = ctrl.bindProperty(row.bind, onChange)
                    sw.connect('state-set', (sw, state) => setter(state))
                    sw.connect('unrealize', (sw) => ctrl.unbindProperty(row.bind, id))
                }

                // add some padding and nice alignment
                addStyles(lane, 'box {padding: 5px;}')
                l.set_hexpand(true)
                l.set_halign(Gtk.Align.START)
                sw.set_halign(Gtk.Align.END)
            }
        }
        return { name:k, widget:box }
    })
}

/** Spec defines a user interface */
class Spec {
    /** @param {object} spec - defines the UI as plain JS object */
    constructor({icons, dialogs, views, main="main", path="."}={}) {
        this.icons   = icons
        this.dialogs = dialogs
        this.views   = views
        this.main    = main
        this.path    = path
    }
}

/**

  buildWidgets builds a GTK widget tree from the given nogui spec.
  
  @param {Spec}   spec        - parsed nogui object tree to be rendered
  @param {str}    path        - path prefix used for all referenced gui resources (icons, docs, etc.)  
  @param {object} data        - data object used to bind fields and handlers
  @param {object} formatters  - named formatters that will be used to format text and documents

*/
function buildWidgets(spec, ctrl=null, path='.', formatters=null) {
    log(`building widgets from ${spec} with asset path ${path}`)
    const icons = buildIcons(spec.icons, path)
    const dialogs = buildDialogs(spec.dialogs, path, formatters)
    const views = buildViews(spec.views, ctrl)
    if (ctrl != null) {
        ctrl._add_dialogs(dialogs)
    }
    return { icons, views, dialogs }
}

if (!this.module) module = {}
module.exports = { buildWidgets, Controller, Binding, bindAll }

/***/ }),

/***/ 883:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
const gi = imports.gi
const { GLib, Gio } = gi
const ByteArray = imports.byteArray

let history = []
let history_index = -1
let line_prefix = ''

/**
 * `readByteCallback` handles a single byte of input
 *
 * @callback readByteCallback
 * @param {GLib.Bytes} byte
 */

/**
 * readByte read a single byte from the `stream` and passes as argument to `cb`.
 * 
 * @param {Gio.InputStream} stream 
 * @param {readByteCallback} cb
 */
function readByte(stream, cb) {
    // start reading and catch potential pipe errors
    try {
        stream.read_bytes_async(1, GLib.PRIORITY_LOW, null, (stream, res) => {
            // process output and catch potential read errors
            try       { cb(stream.read_bytes_finish(res).get_data()) }
            catch (e) { logError(e); cb(null) }
        })
    } catch(e) {
        logError(e); cb(null)
    }
}

// Terminal escape codes to control the cursor an clear lines
// These code will only work if the terminal is in the correct mode.
var TERM = {
    SAVE_CURSOR:     '\0o33[s',    
    RESTORE_CURSOR:  '\0o33[u',
    CLEAR_LINE:      '\0o33[K',
    CLEAR_SCREEN:    '\0o33[2J',
    CURSOR_FORWARD:  '\0o33[2C',
    CURSOR_BACKWARD: '\0o33[2D',
}

var KEYS = {
    UP:        'UP',
    DOWN:      'DOWN',
    LEFT:      'LEFT',
    RIGHT:     'RIGHT',
    CTRL_UP:   'CTRL_UP',
    CTRL_DOWN: 'CTRL_DOWN',
    CTRL_LEFT: 'CTRL_LEFT',
    CTRL_RIGHT:'CTRL_RIGHT',
    ENTER:     'ENTER',
    TAB:       'TAB',
}

var TTYSEQ = {
    UP:         [27,91,65].join(' '),
    DOWN:       [27,91,66].join(' '),
    LEFT:       [27,91,68].join(' '),
    RIGHT:      [27,91,67].join(' '),
    CTRL_UP:    [59,53,65].join(' '),
    CTRL_DOWN:  [59,53,66].join(' '),
    CTRL_LEFT:  [59,53,68].join(' '),
    CTRL_RIGHT: [59,53,67].join(' '),    
}

function getKey(bytes) {
    const last_3 = bytes.slice(-3).join(' ')
    // print('\ntest key:', last_3)
    for (const k in TTYSEQ) {
        if (TTYSEQ[k] == last_3) return KEYS[k]
    }
    return null
}

function put(...s) {
    if (stdout != null) s.forEach(s => stdout.put_string(`${s}`, null))
    else                print(...s)
}

function put_string(...s) {
    if (stdout != null) s.forEach(s => stdout.put_string(s, null))
    else                print(...s)
}

function write_bytes(b) {
    if (stdout != null) stdout.write_bytes(b, null)
    else                print(...s)
}

function clear_line(len) {
    put_string('\r')
    len = history.reduce((l, s) => l > s.length ? l : s.length, len)
    for (let i = 0; i < len; i++) put_string(' ')
    for (let i = 0; i < len; i++) put_string('\b')
    put_string('\r')
}

/**
 * `readLineCallback` handles a single byte of input
 *
 * @callback readLineCallback
 * @param {string} line
 * @param {array}  bytes
 */

/**
 * readLine reads a full line of input from the `stream` and passes the resulting
 * string as first argument and the raw bytes as second argument `cb`.
 * 
 * @param {Gio.InputStream} stream 
 * @param {readLineCallback} cb 
 */
function readBytes(stream, cb) {
    let bytes = []
    let esc = []
    let all = []

    // restore prev input line if required
    if (line_prefix != '') {
        for (const s of line_prefix) {
            bytes.push(s.charCodeAt(0))
        }        
        line_prefix = ''
    }

    const handleByte = (byte) => {
        if (byte == null) return cb(null)
        const code = byte[0]
        const l = esc.length
        all.push(code)
        if      (l == 0 && code == 27) esc[0] = 27
        else if (l == 1 && code == 91) esc[1] = 91
        else if (l == 2 && code == 49) esc[2] = 49
        else if ((l == 2 || l == 5) && code >= 65 && code <= 68) {
            // arrow keys or CTRL + arrow keys
            esc.push(code)
            // put(` // esc:${esc}, all:${all}`)
            return cb(bytes, getKey(esc))
        }
        else if (l == 4 && code == 59) esc[4] = 59
        else if (l == 5 && code == 53) esc[4] = 53
        else if (code == 127) {
            bytes.pop()
            put_string('\b \b')
        }
        else if (code == 10){
            // put(` // all:${all}`)
            return cb(bytes, KEYS.ENTER)
        }
        else if (code == 9 || code == 0){
            // put(` // all:${all}`)
            return cb(bytes, KEYS.TAB)
        }
        else {
            // handle incomplete ESC seq
            if (l > 0) {
                bytes = bytes.concat(esc)
                put_string(String.fromCharCode(...esc))
                esc = []
            }
            // handle unprocessed byte
            bytes.push(code)
            const char = String.fromCharCode(code)
            put_string(char)
        }

        readByte(stream, handleByte)
    }
    // start reading until line end
    readByte(stream, handleByte)
}

/**
 * `readInput` reads lines and bytes from the `stream`, passing them to the callback `cb`.
 * 
 * @param {Gio.InputStream} stream 
 * @param {readLineCallback} cb 
 */
function readInput(stream, cb) {
    if (cb == null) throw new Error('missing callback to process stdin lines')
    // setup line handler that also handles null lines as end of input
    const handleBytes = (bytes, key=null) => {
        if (key == null) {
            return log('input stream closed')
        }
        cb(String.fromCharCode(...bytes), key)
        return readBytes(stream, handleBytes)        
    }
    // start readLine loop
    readBytes(stream, handleBytes)
}

const re_native_code1 = /{\s*.*\[native code\].*\s*}/mi
const re_native_code2 = /{\s*.*wrapper for native.*\s*}/mi

function complete(expr) {
    let end = expr.slice(-1)[0]
    if (end == '*' || end == '.') {
        expr = expr.slice(0, -1)
    } else {
        end = '*'
    }
    // put_string(`complete: ${expr}${end}`)

    if (expr.length == 0) expr = 'window'
    let search = ''
    let obj = null
    switch (end) {
        case '.': break
        case '*':
            let parts = expr.split('.')
            if (parts.length < 2) parts.unshift('window')
            search = parts.slice(-1)[0].replace(/\*/g, '.*')
            search = new RegExp(`^_*${search}.*`)
            expr = parts.slice(0,-1).join('.')
            break
        default:
            logError(new Error(`unsupported expr terminator: ${end}`))
    }
    put_string(`\r// searching: ${expr}.${search}\n`)
    obj = eval(expr)
    let completion = {}    
    Object.keys(obj).forEach((k) => {
        if (search != '' && !k.match(search)) return
        try {
            completion[k] = `${obj[k]}`.replace(re_native_code1, '').replace(re_native_code2, '')
        } catch (e) {
            completion[k] = `ERROR: ${e.message}`
        }
    })
    return completion
}

var RESULT_TYPE = {
    EVAL: 'EVAL',
    COMPLETION: 'COMPLETION',
    ERROR: 'ERROR',
    NONE: 'NONE',
}

function evaluate(line, key=null) {
    let res = {line, obj: null, error: null, type: RESULT_TYPE.EVAL}
    try {
        let expr = line.trim()

        if (key == KEYS.UP) {
            res.type = RESULT_TYPE.NONE            
            if (history_index > 0) {
                history_index--
                res.line = line_prefix = history[history_index]
                clear_line(line.length)
                put_string(line_prefix)
            }
        }
        else if (key == KEYS.DOWN) {
            res.type = RESULT_TYPE.NONE
            if (history.length == 0) return res
            if (history_index < history.length) {
                history_index++
                if(history_index == history.length) {
                    clear_line(line.length)
                } else {
                    res.line = line_prefix = history[history_index]
                    clear_line(line.length)
                    put_string(line_prefix)
                }
            }
        }
        else if (key == KEYS.RIGHT) {
            res.type = RESULT_TYPE.NONE
            put_string(' ')
        }
        else if (key == KEYS.LEFT) {
            res.type = RESULT_TYPE.NONE
            put_string('\b \b')
        }
        else if (expr.match(/.*[\.\*]$/) || key == KEYS.TAB) {
            // put_string(` searching for '${expr}'\n`)
            res.obj = complete(expr)
            res.type = RESULT_TYPE.COMPLETION
        }
        else {
            // put_string(` eval: ${expr}`)
            res.obj = eval(line)
            res.type = RESULT_TYPE.EVAL
        }
        return res
    } catch(e) {
        res.error = e
        res.type = RESULT_TYPE.ERROR
        return res       
    }
}

let stdout = null
try {
    stdout = new Gio.DataOutputStream({
        base_stream: new Gio.UnixOutputStream({ fd: 1 })
    })
    log('using fd=1 as stdout for repl')
} catch(e) {
    // ignore
}

function startRepl(stream, cb=null, context=null) {
    readInput(stream, (line, key=null) => {
        let res = evaluate(line, key)
        // print(JSON.stringify(res))
        if (cb != null) return cb(res)
        switch (res.type) {
        case RESULT_TYPE.ERROR:
            put_string(`  // ERROR: ${res.error.message}, LINE: ${line}`)
            break;
        case RESULT_TYPE.EVAL:
            put_string(`, res: ${res.obj}\n`)
            history = history.slice(-100).filter(l => l != res.line)
            history.push(res.line)
            history_index = history.length
            break;
        case RESULT_TYPE.COMPLETION:
            if (res.obj == null) {
                put_string(`  // no completion for ${line}`)
            }
            Object.keys(res.obj).sort().forEach(k => {
               print(`${k}: ${res.obj[k]}`)
            })
            break;
        }
    })
}

if (!this.module) module = {}
module.exports = { startRepl }

/***/ }),

/***/ 304:
/***/ ((module) => {

"use strict";
module.exports = imports.byteArray;

/***/ }),

/***/ 311:
/***/ ((module) => {

"use strict";
module.exports = imports.gi;

/***/ }),

/***/ 768:
/***/ ((module) => {

"use strict";
module.exports = imports.system;

/***/ }),

/***/ 59:
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__(__webpack_require__.s = 464);
/******/ 	gtk4demo = __webpack_exports__;
/******/ 	
/******/ })()
;